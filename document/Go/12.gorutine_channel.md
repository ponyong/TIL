# 고루틴과 채널

- Goal
    - 고루틴에 개념에 대해 이해한다.
    - 채널에 개념에 대해 이해한다.
    - 동시성 프로그래밍에 대해 이해한다.

## 8.1 고루틴

Go에서는 동시에 수행되는 작업을 고루틴이라고 한다.

프로그램이 시작된 뒤 유일한 고루틴은 main 함수를 호출하는 것으로

이를 메인 고루틴이라고 하며 새로운 고루틴은 go문에 의해 생성된다.

 

```go
package main 

import (
	"fmt"
	"time"
)

func say(s string) {
		for i := 0; i < 10; i++ {
				fmt.Println(s, "***", i )
		}
}

func main () {
		say("Sync")
		
		go say("Async1")
		go say("Async2")
		go say("Async3")

		time.Sleep(time.Second * 3)
}
```

## 8.2 예제 : 동시 시계 서버

## 8.3 예제 : 동시 에코 서버

## 8.4 채널

고루틴이 프로그램의 동작을 나타낸다면  채널은 고루틴간의 연결이다. 

한 고루틴이 다른 고루틴으로 값을 보내기 위한 통신 매커니즘

각 채널은 요소 타입이라는 특정 타입 값의 통로로써 

int 타입의 요소를 갖는 채널은 chan int로 작성한다. 

채널을 생성하려면 내장된 make() 함수를 사용한다.

```go
ch := make(chan int) 
```

맵과 마찬가지로 make로 생성된 데이터 구조에 대한 참조라서

채널을 복사하거나 함수의 인자로 전달 할 때 참조를 복사하기 때문에 

호출자와 피호출자는 같은 데이터 구조를 참조 한다. 

다른 것과 마찬가지로 채널의 제로 값은 nil 값을 가지고 있으며

같은 타입의 두 채널은 == 로 비교할 수 있다. 

채널에는 합쳐서 통신이라고 부르는 주요 작업 "송신" 과 "수신" 이 있는데 

송신 구문은 한 고루틴에서 채널을 통해 그에 대응하는 수신 표현식이 있는

다른 고루틴으로 값을 전달하고, 송신 구문에서는 < - 로 채널과 값 피연산자를

분리한다. 수신 표현식에서는 < - 가 채널 피연산자 앞에 온다. 결과를 사용하지 않는

수신 표현식도 유효하다. 

```go
ch <- x // 송신 구문
x = <- ch // 할당문 안의 수신 표현식
<-ch    // 수신 구문 결과는 버려짐 
```

채널의 세 번째 작업인 close는 이 채널에 더 이상 값을 보내지 않음을 나타내는

플래그를 설정하는 것이다. close를 한 이후에 송신을 시도하면 패닉이 발생한다.

닫힌 채널에 대한 수신 작업은 지금까지 송신 된 값을 더 이상 남아있지 않을 때까지

산출한다. 

이 후 수신작업은 즉시 완료되며, 채널 요소 타입의 제로 값을 산출한다. 

기본 make 호출로 생성된 채널은 버퍼 없는 채널이지만 make에 부가적인

두 번째 정수 인자로 채널의 용량을 지정 할 수 있다. 용량이 0이 아닌 경우

버퍼 채널을 생성 한다. 

```go
ch = make(chan int)     // 버퍼 없는 채널
ch = make(chan int, 0)  // 버퍼 없는 채널
ch = make(chan int, 3)  // 용량이 3인 버퍼 채널
```

### 8.4.2 버퍼 없는 채널

버퍼 없는 채널에 대한 송신 작업은 동일 채널상에서 이에 대응하는 고루틴이

값의 수신을 완료해 두 고루틴이 재개 할 수 있을 때까지 보내는 고루틴을

중단시킨다. 반대로 수신 작업이 먼저 시도 했다면 수신하는 고루틴은 

동일 채널상의 다른 고루틴이 송신을 수행할 때까지 중단 됨. 

버퍼 없는 채널에서 통신은 송신과 수신이 동기화 되고 , 이 때문에 

버퍼 없는 채널은 동기 채널이라고 부른다. 

값이 없는 다른