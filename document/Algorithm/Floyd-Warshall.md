# Floyd-Warshall 알고리즘 

## <이 알고리즘으로 해결하고자 하는 것>

```
그래프 구조에서 최단거리를 구하고자 하는 알고리즘
```
## <핵심 이론>

```
  모든 정점 에서 모든 정점으로의 최단 경로를 구한다.
```

## <핵심 변수>
```java
int[][] map // 거리 배열

int[][] result // 결과 배열
``` 
## <핵심 코드>
```java
public static void floydWarshall() {
	// 기준이 되는 거쳐가는 노드 K
	for(int k = 1; k <= N; k++) {
		// 출발하는 노드 i
		for(int i=1; i <= N; i++) {
			// 도착하는 노드 j
			for(int j=1; j <= N; j++) {
			//i에서 k를 거쳤다가 k에서 j 까지 가는 거리와 i에서 j 까지 가는 거리를 비교해서 작은 값이 최소거리이다.
				distance[i][j] = Math.min(distance[i][k] + distance[k][j], distance[i][j]);
			}
		}
	}
}
```
## <알고리즘 진행 순서>
```
1. 기준이 될 거쳐가는 노드를 설정한다 k

2. 모든 거리 배열을 돌면서 
   i 에서 k를 거쳐 j 를 가는 경로와 i에서 j로 가는 경로를 비교하여 작은값을 갱신한다.

3. 1 ~ 2 의 과정을 모든 노드를 기준으로 반복한다.
```
## <시간 복잡도 및 최적화 개선사항>
```
정점의 개수를 V 라고 했을 때  O(V^3) 의 시간 복잡도를 갖는다.

1억을 1초에 연산한다고 가정 했을때 정점의 개수가 약 500개 이상일 경우

시간초과가 발생한다.

그럼에도 플로이드 와샬 알고리즘은 코드가 간결하고 모든 정점쌍에 대한

경로를 구할시에는 다익스트라와 같은 O(v^3) 시간이 소모되지만 

플로이드 와샬 알고리즘이 조금더 빠르다.
```